package org.mc.parser;

import org.mc.lexer.*;
import scala.collection.JavaConversions;
import scala.collection.immutable.Seq;
import java.util.ArrayList;

parser code {:

public static scala.Option<UnaryOperator> makeUnaryOperator() {
    return scala.Option.<UnaryOperator>apply(null);
}

public static scala.Option<UnaryOperator> makeUnaryOperator(UnaryOperator operator) {
    return scala.Option.<UnaryOperator>apply(operator);
}

public static ExpressionList makeExpressionList(Ast value) {
    java.util.List<Ast> list = new ArrayList<Ast>();
    list.add(value);
    Seq<Ast> result = JavaConversions.asScalaBuffer(list).toList();
    return new ExpressionList(result);
}

public static ExpressionList makeExpressionList(Seq<Ast> list, Ast value) {
    java.util.List<Ast> immutableList = JavaConversions.seqAsJavaList(list);
    java.util.List<Ast> mutableList = new ArrayList<Ast>();
    mutableList.addAll(immutableList);
    mutableList.add(value);
    Seq<Ast> result = JavaConversions.asScalaBuffer(mutableList).toList();
    return new ExpressionList(result);
}

:}

// terminals
terminal VAR, VAL;
terminal SEMICOLON, ASSIGN, PLUS, MINUS, TIMES, DIVIDE;
terminal UNARY_MINUS, LPAREN, RPAREN;
terminal IdToken        ID;
terminal StringToken    STRING;
terminal DecNumberToken DEC_NUMBER;

// non-terminals
non terminal ExpressionList ast;
non terminal Ast expr_part, expr;
non terminal Ast val_definition, var_definition;

// precedences
precedence right ASSIGN;
precedence left  PLUS, MINUS;
precedence left  TIMES, DIVIDE;
precedence left  UNARY_MINUS;

// grammar
ast ::= ast:self expr_part:exprPart
        {: RESULT = Parser.makeExpressionList(self.children(), exprPart); :}
        |
        expr_part:exprPart
        {: RESULT = Parser.makeExpressionList(exprPart); :}
        ;

expr_part ::= expr:e SEMICOLON
              {: RESULT = e; :}
              |
              val_definition:val
              {: RESULT = val; :}
              |
              var_definition:var
              {: RESULT = var; :}
              |
              error SEMICOLON
              {: RESULT = new ErrorExpression(); :}
              ;

expr ::= expr:e1 PLUS expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new AddOperator()); :}
         |
         expr:e1 MINUS expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new SubOperator()); :}
         |
         expr:e1 TIMES expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new MulOperator()); :}
         |
         expr:e1 DIVIDE expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new DivOperator()); :}
         |
         expr:e1 ASSIGN expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new AssignOperator()); :}
         |
         ID:id
         {: RESULT = new IdConstant(id); :}
         |
         STRING:str
         {: RESULT = new StringConstant(str); :}
         |
         DEC_NUMBER:num
         {: RESULT = new DecConstant(num); :}
         |
         MINUS expr:e
         {: RESULT = new UnaryExpression(e, Parser.makeUnaryOperator(new UnarySubOperator())); :}
         %prec UNARY_MINUS
         |
         LPAREN expr:e RPAREN
         {: RESULT = e; :}
         ;

val_definition ::= VAL ID:id ASSIGN expr:e
                   {: RESULT = new ValueDefinition(id, e); :}
                   ;

var_definition ::= VAR ID:id ASSIGN expr:e
                   {: RESULT = new VariableDefinition(id, e); :}
                   ;