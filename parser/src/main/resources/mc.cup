package org.mc.parser;

import org.mc.lexer.*;
import scala.collection.immutable.List;
import scala.collection.immutable.List$;
import scala.collection.immutable.$colon$colon;

parser code {:

public static scala.Option<UnaryOperator> makeUnaryOperator() {
    return scala.Option.<UnaryOperator>apply(null);
}

public static scala.Option<UnaryOperator> makeUnaryOperator(UnaryOperator operator) {
    return scala.Option.<UnaryOperator>apply(operator);
}

public static Block makeBlock(Ast value) {
    List<Ast> list = List$.MODULE$.empty();
    return extendBlock(list, value);
}

public static Block extendBlock(List<Ast> list, Ast value) {
    list = new $colon$colon(value, list);
    return new Block(list);
}

:}

// terminals
terminal VAR, VAL, DEF, CLASS, INTERFACE, PUBLIC, PRIVATE, FINAL, EXTENDS, IMPLEMENTS, OVERRIDE, AS, IS, THIS, SUPER;
terminal SEMICOLON, COLON, COMMA, ASSIGN, PLUS, MINUS, TIMES, DIVIDE;
terminal UNARY_MINUS, OPEN_PAREN, CLOSE_PAREN, OPEN_CURLY_BRACE, CLOSE_CURLY_BRACE;
terminal IdToken        ID;
terminal StringToken    STRING;
terminal DecNumberToken DEC_NUMBER;

// non-terminals
non terminal Block ast;
non terminal Ast expr_part, expr;
non terminal Ast val_definition, var_definition;
non terminal AccessModifier access_modifier;
non terminal ClassModifiers class_modifiers;
non terminal String base_class;
non terminal List<String> base_interfaces;
non terminal ClassDeclaration class_declaration;
non terminal InterfaceDeclaration interface_declaration;
non terminal IdToken type_specification;

// precedences
precedence right ASSIGN;
precedence left  PLUS, MINUS;
precedence left  TIMES, DIVIDE;
precedence left  UNARY_MINUS;

// grammar
ast ::= ast:self expr_part:exprPart
        {: RESULT = Parser.extendBlock(self.expressions(), exprPart); :}
        |
        expr_part:exprPart
        {: RESULT = Parser.makeBlock(exprPart); :}
        ;

expr_part ::= expr:e SEMICOLON
              {: RESULT = e; :}
              |
              OPEN_CURLY_BRACE expr_part:exprPart CLOSE_CURLY_BRACE
              {: RESULT = Parser.makeBlock(exprPart); :}
              |
              val_definition:val SEMICOLON
              {: RESULT = val; :}
              |
              var_definition:var SEMICOLON
              {: RESULT = var; :}
              |
              error SEMICOLON
              {: RESULT = new ErrorExpression(); :}
              ;

expr ::= expr:e1 PLUS expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new AddOperator()); :}
         |
         expr:e1 MINUS expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new SubOperator()); :}
         |
         expr:e1 TIMES expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new MulOperator()); :}
         |
         expr:e1 DIVIDE expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new DivOperator()); :}
         |
         expr:e1 ASSIGN expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new AssignOperator()); :}
         |
         ID:id
         {: RESULT = new IdConstant(id); :}
         |
         STRING:str
         {: RESULT = new StringConstant(str); :}
         |
         DEC_NUMBER:num
         {: RESULT = new DecConstant(num); :}
         |
         MINUS expr:e
         {: RESULT = new UnaryExpression(e, Parser.makeUnaryOperator(new UnarySubOperator())); :}
         %prec UNARY_MINUS
         |
         OPEN_PAREN expr:e CLOSE_PAREN
         {: RESULT = e; :}
         ;

type_specification ::= COLON ID:id
         {: RESULT = id; :}
         ;

val_definition ::= VAL ID:id type_specification:type ASSIGN expr:e
                   {: RESULT = new ValueDefinition(id, e); :}
                   |
                   VAL ID:id ASSIGN expr:e
                   {: RESULT = new ValueDefinition(id, e); :}
                   ;

var_definition ::= VAR ID:id type_specification:type ASSIGN expr:e
                   {: RESULT = new VariableDefinition(id, e); :}
                   |
                   VAR ID:id ASSIGN expr:e
                   {: RESULT = new VariableDefinition(id, e); :}
                   ;

access_modifier ::= PUBLIC
                     {: RESULT = new Public(); :}
                     |
                     PRIVATE
                     {: RESULT = new Private(); :}
                     ;

class_modifiers ::= access_modifier:access FINAL
                    {: RESULT = new ClassModifiers(access, true); :}
                    |
                    access_modifier:access
                    {: RESULT = new ClassModifiers(access, false); :}
                    |
                    FINAL
                    {: RESULT = new ClassModifiers(new Private(), true); :} // default access modifier is 'private'
                    ;

base_class ::= EXTENDS ID:baseClassName
               {: RESULT = baseClassName.name; :}
               ;

base_interfaces ::= IMPLEMENTS ID:baseInterfaceName
                    {: List<String> list = List$.MODULE$.empty();
                       RESULT = new colon$colon$(baseInterfaceName, list); :}
                    |
                    base_interfaces:list COMMA ID:baseInterfaceName
                    {: RESULT = new colon$colon$(baseInterfaceName, list); :}
                    ;

class_declaration ::= class_modifiers:modifiers ID:className
                      {: RESULT = new ClassDeclaration(className, modifiers, scala.Option.<String>apply(null),
                                                       List$.MODULE$.empty()); :}
                      |
                      ID:className
                      {: RESULT = new ClassDeclaration(className, new ClassModifiers(new Private(), false),
                                                       scala.Option.<String>apply(null), List$.MODULE$.empty()); :}
                      |
                      class_modifiers:modifiers ID:className base_class:baseClassName
                      {: RESULT = new ClassDeclaration(className, modifiers, scala.Option.<String>apply(baseClassName),
                                                       List$.MODULE$.empty()); :}
                      |
                      ID:className base_class
                      {: RESULT =  :}
                      ;

interface_declaration ::=