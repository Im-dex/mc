package org.mc.parser;

import org.mc.lexer.*;
import scala.collection.immutable.List;
import scala.collection.immutable.List$;
import scala.collection.immutable.$colon$colon;

parser code {:

public static scala.Option<UnaryOperator> makeUnaryOperator() {
    return scala.Option.<UnaryOperator>apply(null);
}

public static scala.Option<UnaryOperator> makeUnaryOperator(UnaryOperator operator) {
    return scala.Option.<UnaryOperator>apply(operator);
}

public static ExpressionsBlock makeExpressionsBlock(Ast value) {
    List<Ast> list = List$.MODULE$.empty();
    return extendExpressionsBlock(list, value);
}

public static ExpressionsBlock extendExpressionsBlock(List<Ast> list, Ast value) {
    list = new $colon$colon(value, list);
    return new ExpressionsBlock(list);
}

:}

// terminals
terminal VAR, VAL;
terminal SEMICOLON, COLON, ASSIGN, PLUS, MINUS, TIMES, DIVIDE;
terminal UNARY_MINUS, LPAREN, RPAREN;
terminal IdToken        ID;
terminal StringToken    STRING;
terminal DecNumberToken DEC_NUMBER;

// non-terminals
non terminal ExpressionsBlock ast;
non terminal Ast expr_part, expr;
non terminal Ast val_definition, var_definition;
non terminal IdToken type_specification;

// precedences
precedence right ASSIGN;
precedence left  PLUS, MINUS;
precedence left  TIMES, DIVIDE;
precedence left  UNARY_MINUS;

// grammar
ast ::= ast:self expr_part:exprPart
        {: RESULT = Parser.extendExpressionsBlock(self.expressions(), exprPart); :}
        |
        expr_part:exprPart
        {: RESULT = Parser.makeExpressionsBlock(exprPart); :}
        ;

expr_part ::= expr:e SEMICOLON
              {: RESULT = e; :}
              |
              val_definition:val SEMICOLON
              {: RESULT = val; :}
              |
              var_definition:var SEMICOLON
              {: RESULT = var; :}
              |
              error SEMICOLON
              {: RESULT = new ErrorExpression(); :}
              ;

expr ::= expr:e1 PLUS expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new AddOperator()); :}
         |
         expr:e1 MINUS expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new SubOperator()); :}
         |
         expr:e1 TIMES expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new MulOperator()); :}
         |
         expr:e1 DIVIDE expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new DivOperator()); :}
         |
         expr:e1 ASSIGN expr:e2
         {: RESULT = new BinaryExpression(e1, e2, new AssignOperator()); :}
         |
         ID:id
         {: RESULT = new IdConstant(id); :}
         |
         STRING:str
         {: RESULT = new StringConstant(str); :}
         |
         DEC_NUMBER:num
         {: RESULT = new DecConstant(num); :}
         |
         MINUS expr:e
         {: RESULT = new UnaryExpression(e, Parser.makeUnaryOperator(new UnarySubOperator())); :}
         %prec UNARY_MINUS
         |
         LPAREN expr:e RPAREN
         {: RESULT = e; :}
         ;

type_specification ::= COLON ID:id
         {: RESULT = id; :}
         ;

val_definition ::= VAL ID:id type_specification:type ASSIGN expr:e
                   {: RESULT = new ValueDefinition(id, e); :}
                   |
                   VAL ID:id ASSIGN expr:e
                   {: RESULT = new ValueDefinition(id, e); :}
                   ;

var_definition ::= VAR ID:id type_specification:type ASSIGN expr:e
                   {: RESULT = new VariableDefinition(id, e); :}
                   |
                   VAR ID:id ASSIGN expr:e
                   {: RESULT = new VariableDefinition(id, e); :}
                   ;