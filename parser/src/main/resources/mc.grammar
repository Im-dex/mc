%package "org.mc.parser";
%import "org.mc.lexer.*";
%import "org.mc.parser.*";
%class "McParser";

%terminals ID, STRING, DEC_NUMBER;
%terminals OPEN_PAREN, CLOSE_PAREN;
%terminals SEMICOLON, COLON, COMMA, ASSIGN, PLUS, MINUS, TIMES, DIVIDE;
%terminals VAR, VAL, DEF, CLASS, INTERFACE, PUBLIC, PRIVATE, FINAL, EXTENDS, IMPLEMENTS, OVERRIDE, AS, IS, THIS, SUPER;

%left OPEN_PAREN, CLOSE_PAREN;
%right UNARY_MINUS;
%left TIMES, DIVIDE;
%left PLUS, MINUS, TIMES, DIVIDE;
%right ASSIGN;

%typeof ID = "IdToken";
%typeof STRING = "StringToken";
%typeof DEC_NUMBER = "DecNumberToken";

%typeof ast = "Ast";
%typeof expr = "Expression";
%typeof sub_expr = "Expression";

%goal ast;

ast
    = expr.e* {: return new ExpressionList(ScalaUtils.makeList(e)); :}
    ;

expr
    = sub_expr.e SEMICOLON {: return e; :}
    | SEMICOLON            {: return new EmptyExpression(); :}
    | error SEMICOLON.semi {: return new ErrorExpression(((TokenPosition)semi.value).index()); :}
    ;

sub_expr
    = sub_expr.left PLUS sub_expr.right   {: return new AddExpression(left, right); :}
    | sub_expr.left MINUS sub_expr.right  {: return new SubExpression(left, right); :}
    | sub_expr.left TIMES sub_expr.right  {: return new MulExpression(left, right); :}
    | sub_expr.left DIVIDE sub_expr.right {: return new DivExpression(left, right); :}
    | MINUS sub_expr.e @ UNARY_MINUS      {: return new MinusExpression(e); :}
    | OPEN_PAREN sub_expr.e CLOSE_PAREN   {: return new ParenthesizedExpression(e); :}
    | ID                                  {: return new IdLiteral(); :}
    | STRING                              {: return new StringLiteral(); :}
    | DEC_NUMBER                          {: return new DecNumberLiteral(); :}
    ;

